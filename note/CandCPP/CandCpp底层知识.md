# 编译原理
![[Pasted image 20230410205915.png]]
编译型语言的底层基本知识
[编译原理](https://blog.csdn.net/qq_43412060/article/details/104696922)

# 内存分区模型
意义：
不同区域存放数据，赋予不同生命周期，给我们更大灵活编程
## 程序运行前
生成exe可执行程序，未执行该程序前分为两个区域

### 代码区
存放CPU执行的指令
代码区是**共享**的，共享目的是对于被频繁执行的程序，只需在内存中有一份即可
代码区是**只读**的，只读的原因是防止程序意外修改它的指令
-   字符串常量和define定义的常量也有可能存放在代码区。

### 全局区
-   全局变量和静态变量存放至此
-   全局区有 **.bss段** 和 **.data段**组成，可读可写。(常量区也在全局区内)
<font color="rgb(200, 100, 100)">该区域的数据在程序结束后由操作系统释放</font>
```cpp
//全局变量
int _a_;
int _b_;
//const全局变量
const int g_A_ = 0;
const int g_B_ = 0;
int main()
{
	//局部变量
	int a = 0;
	int b = 0;
	//静态变量
	static int s_a = 0;
	static int s_b = 0;
	cout << (int)&a << endl;
	cout << (int)&b << endl;
	//output:12385260  (随机)
	//12385248
	cout << (int)&_a_ << endl;
	cout << (int)&_b_ << endl;
	//output:10338356  (随机)
	//10338360
	cout << (int)&s_a << endl;
	cout << (int)&s_b << endl;
	//output:10338364  (随机)
	//10338368
	
	//字符串常量
	cout << (int)&"Hello World" << endl;
	//output:10334260  (随机)
	//const修饰变量
	//const修饰全局变量、局部变量
	cout << (int)&g_A_ << endl;
	cout << (int)&g_B_ << endl;
	//output:10335460  (随机)
	//10335464
	const int A = 0;
	const int B = 0;
	cout << (int)&A << endl;
	cout << (int)&B << endl;
	//output:45257248  (随机)
	//45257236
}
//局部变量和全局变量存放区域不同
//以上输出结果随机变化
```
由上文可知局部变量、const修饰的局部变量(局部常量)不在全局区中
全局变量、静态变量、常量->字符串常量、const修饰的全局变量(全局常量)在全局区
#### bss段
-   未初始化的**全局变量**和未初始化的**静态变量**存放**在.bss段。**
-   初始化为0的**全局变量**和初始化为0的**静态变量**存放**在.bss段。**
-   .bss段不占用可执行文件空间，其内容由操作系统初始化。
### data段
-   已初始化的**全局变量**存放在.data段。
-   已初始化的**静态变量**存放在.data段。
-   .data段占用可执行文件空间，其内容有程序初始化。
#### 常量区
-   **字符串**、**数字**等常量存放在常量区。
-   **const修饰的全局变量**存放在常量区。
-   程序运行期间，**常量**区的内容不可以被修改。

### 栈区
-   **栈区**由编译器**自动分配释放**，由操作系统自动管理，无须手动管理。
-   **栈区**上的内容只在函数范围内存在，当函数运行结束，这些内容也会**自动被销毁**。
-   **栈区**按内存地址**由高到低**方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。
-   **栈区**是**先进后出**原则，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。
-   临时创建的**局部变量**和**const定义的局部变量**存放在**栈区**。
-   函数调用和返回时，其入口**参数**和**返回值**存放在**栈区**。
<font color="rgb(200, 100, 100)">不要返回局部变量的地址</font>
```cpp
int* func()
{
	int a = 10;
	return &a;
}

int main()
{
	int* p = func();
	cout << *p << endl;
	cout << *p << endl;
	//output:10
	//7654345665  (随机)

//第一次是因为编译器做了正确处理，部分编译器会做不同处理
//第二次数据不再保留(vs2022无限保留)
//返回局部变量地址本身就是非法操作
}
```

### 堆区
-   **堆区**由程序员分配内存和释放。
-   **堆区**按内存地址**由低到高**方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。
```cpp
//new关键字，将数据开辟到堆区
//指针本身是局部变量，放在栈上，指针保存的数据是放在堆区
int* p = new int(10);
cout << *p << endl;
cout << *p << endl;
cout << *p << endl;
cout << *p << endl;
/*output:
10
10
10
10*/
```

