# 智能指针的介绍
普通指针的不足:
- new的指针要delete手动释放
- 开发者主管失误忘记释放
- 开发者也不确定合适释放
- 类内指针必须在析沟释放
所以有了智能指针，自动回收
智能指针的优点:
- 是类模板，在栈上创建智能指针对象
- 普通指针交给智能指针对象
- 智能指针对象过期时，调用析构函数释放普通指针内存

# 智能指针类型
- `auto_ptr` 以弃用
C++11标准新增三个智能指针
包含头文件`#include <memory>`
- `unique_ptr`
- `shared_ptr`
- `weak_ptr`

# unique_ptr(since C++11)
`unique_ptr<类名> 指针名(被管理指针);`
`unique_ptr`独享它指向的对象，也就是说，同时只有一个`unique_ptr`指向同一对象，当这个`unique_ptr`被销毁时，指向对象也被销毁
```ad-important
title:Important
collapse:open
```
```cpp
class Person{
public:
    int m_age;
    Person(){cout << "调用" << endl;}
    ~Person(){cout << "析构" << endl;}
};

int main()
{
    Person *p = new Person;
    unique_ptr<Person> u_ptr1(p);
    p->m_age = 0;
    cout << p->m_age << " " << (*p).m_age << endl;
    cout << u_ptr1->m_age << " " << (*u_ptr1).m_age << endl;
    return 0;
}
/*output:
调用
0 0
0 0
析构
*/
```

## 初始化方法
方法一:`unique_ptr<Person> up1(new Person);`
方法二:`unique_ptr<Person> up2 = make_unique<Person>();` C++14
方法三:
`Person *p = new Person;`
`unique_ptr<Person> up3(p);`

## 注意事项
```ad-warning
title:warning
collapse:open
- 不能把普通指针赋值给智能指针
- 不能用其他unique_ptr进行拷贝构造
- 不能用=对其他unique_ptr进行赋值
- 不要用裸指针初始化多个智能指针对象
- 不要用unique_ptr管理不是new出来的内存
- 不支持指针运算
- 不要在函数传参时用值传递
```

## 使用建议
```ad-important
title:Important
collapse:open
- get()返回裸指针
- 做函数参数时建议传引用或者裸指针
```

## 更多技巧
```ad-example
title:Example
collapse:open
```
```cpp
class A{
public:
    A(string name){cout << "构造" << name << endl;}
    ~A(){cout << "析构" << endl;}
    
};

unique_ptr<A> func()
{
    unique_ptr<A> pp(new A("1"));
    return pp;
}
int main()
{
    unique<A>pu2;
    //匿名函数赋值
    pu2 = unique_ptr<A>(new A("2"));
    cout << "func前" << endl;
    //函数赋值
    pu2 = func();
    cout << "func后" << endl;
    return 0;
}
/*output:
构造1
func前
构造2
func后
构造2
构造1
*/
```

## 详细信息
> [!warning] 
> - 空指针赋值给智能指针将会使智能指针管理的对象释放
> - 如果右值是临时值则编译器允许赋值给智能指针，如果右值将存在一段时间，则编译器禁止赋值
> - 

# shared_ptr(since C++11)
`shared_ptr<类名> 指针名(被管理指针);`

